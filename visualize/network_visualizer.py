import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget
import networkx as nx
import warnings
import sys

warnings.filterwarnings('ignore', category=DeprecationWarning)


class NetworkVisualizer(QMainWindow):
    '''
    Visualizes a neural network generated by the NEAT algorithm in a PyQt window.

    This will involve graphing the nodes and connections in a way that clearly shows the structure of the network.
    '''

    def __init__(self):
        """
        Initialize a new NetworkVisualizer object.
        """
        super().__init__()

        # Create a figure and a canvas to draw on.
        self.figure = plt.figure()
        self.canvas = FigureCanvas(self.figure)

        # Create a layout and add the canvas to it.
        layout = QVBoxLayout()
        layout.addWidget(self.canvas)

        # Create a central widget for the main window and set the layout.
        central_widget = QWidget()
        central_widget.setLayout(layout)
        self.setCentralWidget(central_widget)

    def visualize(self, network):
        """
        Generate a visualization of the given network.

        Args:
            network: The network to visualize.
        """
        # Clear the current figure.
        self.figure.clear()

        # Create a graph with networkx.
        G = nx.DiGraph()

        # Process the network.
        for layer in network:
            for node, incoming, outgoing in layer:
                for input_node, weight in incoming.items():
                    G.add_edge(input_node, node, weight=weight)
                for output_node, weight in outgoing.items():
                    G.add_edge(node, output_node, weight=weight)

        # Find the size of the largest layer.
        max_layer_size = max(len(layer) for layer in network)

        # Compute the positions of the nodes.
        pos = {node: (i, max_layer_size / 2 - j + len(layer) / 2 - 0.5) for i, layer in enumerate(network) for
               j, (node, _, _) in enumerate(layer)}

        # Draw the nodes.
        nx.draw_networkx_nodes(G, pos)

        # Draw the edges with line widths proportional to their weights.
        for edge in G.edges(data=True):
            nx.draw_networkx_edges(G, pos, edgelist=[edge], width=edge[2]['weight'])

        # Draw the labels with an offset.
        label_pos = {node: (x, y + 0.2) for node, (x, y) in pos.items()}  # Offset the y-position of the labels by 0.1
        nx.draw_networkx_labels(G, label_pos)

        # Adjust the limits of the y-axis to include some extra space for the labels.
        plt.ylim(min(y for x, y in pos.values()) - 1, max(y for x, y in pos.values()) + 1)

        # Draw the figure on the canvas.
        self.canvas.draw()


if __name__ == '__main__':
    # Create a PyQt application.
    app = QApplication(sys.argv)

    # Create a network to visualize.
    network = [
        [('input1', {}, {'hidden1': 0.5}), ('input2', {}, {'hidden1': -0.5})],
        [('hidden1', {'input1': 0.5, 'input2': -0.5}, {'output': 1})],
        [('output', {'hidden1': 1}, {})]
    ]

    # Create a NetworkVisualizer and visualize the network.
    nv = NetworkVisualizer()
    nv.visualize(network)
    nv.show()

    # Start the PyQt event loop.
    sys.exit(app.exec_())
